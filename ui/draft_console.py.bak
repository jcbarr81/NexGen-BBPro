from __future__ import annotations

"""Minimal Draft Console (phase 2 scaffold).

Pauses on Draft Day; can generate a pool, compute a draft order, and auto‑draft
one round while persisting state/results. UI will be expanded in later phases.
"""

from PyQt6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QLabel,
    QPushButton,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QHBoxLayout,
    QLineEdit,
    QFrame,
    QGridLayout,
)
from PyQt6.QtCore import Qt

from playbalance.draft_pool import generate_draft_pool, save_draft_pool, load_draft_pool
from services.draft_state import (
    compute_order_from_season_stats,
    initialize_state,
    load_state,
    save_state,
    append_result,
)
from utils.news_logger import log_news_event
from utils.team_loader import load_teams


class DraftConsole(QDialog):
    def __init__(self, draft_date: str, parent=None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Amateur Draft — Commissioner's Console")
        self.resize(1000, 620)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 16, 16, 16)
        layout.setSpacing(12)

        self.DRAFT_ROUNDS = 10

        year = int(draft_date.split("-")[0]) if draft_date else 0
        self.year = year
        self.banner = QLabel(f"Draft Day: {draft_date}")
        bfont = self.banner.font()
        bfont.setPointSize(max(bfont.pointSize()+2, 12))
        bfont.setBold(True)
        self.banner.setFont(bfont)
        layout.addWidget(self.banner)
        self.status = QLabel("Draft pool not generated yet.")
        layout.addWidget(self.status)

        btn_gen = QPushButton("Generate Draft Pool")
        btn_order = QPushButton("Compute Draft Order")
        btn_start = QPushButton("Auto Draft All")
        btn_make = QPushButton("Make Pick")
        btn_auto_this = QPushButton("Auto Pick (This Team)")
        btn_commit = QPushButton("Commit Draftees to Rosters")
        btn_close = QPushButton("Close")
        btn_gen.setObjectName("Primary")
        btn_order.setObjectName("Primary")
        btn_start.setObjectName("Primary")
        row_btns = QHBoxLayout()
        row_btns.addWidget(btn_gen)
        row_btns.addWidget(btn_order)
        row_btns.addWidget(btn_start)
        layout.addLayout(row_btns)

        # Main area: left (pool) | right (on-clock + preview + board)
        main = QHBoxLayout()
        layout.addLayout(main, 1)

        # Left: pool table + search
        left = QVBoxLayout()
        self.table = QTableWidget(0, 6)
        self.table.setHorizontalHeaderLabels(["ID", "Name", "Pos", "B/T", "CH/PH/SP", "ARM/FA"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        left.addWidget(self.table, 1)
        sr = QHBoxLayout()
        sr.addWidget(QLabel("Search:"))
        self.search = QLineEdit()
        sr.addWidget(self.search, 1)
        left.addLayout(sr)
        main.addLayout(left, 2)

        # Right: on-the-clock, preview, and recent picks board
        right = QVBoxLayout()
        right.setSpacing(8)
        self.onclock = QLabel("On the clock: —")
        of = self.onclock.font()
        of.setBold(True)
        self.onclock.setFont(of)
        right.addWidget(self.onclock)

        # Preview panel
        self.preview = QFrame()
        self.preview.setFrameShape(QFrame.Shape.StyledPanel)
        grid = QGridLayout(self.preview)
        grid.setContentsMargins(8, 8, 8, 8)
        grid.setHorizontalSpacing(12)
        grid.setVerticalSpacing(6)
        self._pv_labels = {
            "id": QLabel("ID:"),
            "name": QLabel("Name:"),
            "pos": QLabel("Pos:"),
            "bt": QLabel("B/T:"),
            "hit": QLabel("CH/PH/SP:"),
            "def": QLabel("ARM/FA:"),
        }
        self._pv_values = {k: QLabel("—") for k in self._pv_labels}
        for row, key in enumerate(["id", "name", "pos", "bt", "hit", "def"]):
            grid.addWidget(self._pv_labels[key], row, 0)
            grid.addWidget(self._pv_values[key], row, 1)
        right.addWidget(self.preview)

        # Recent picks board (top 10)
        self.board = QTableWidget(0, 3)
        self.board.setHorizontalHeaderLabels(["Pick", "Team", "Player"])
        self.board.verticalHeader().setVisible(False)
        self.board.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        right.addWidget(QLabel("Recent Picks:"))
        right.addWidget(self.board, 1)
        main.addLayout(right, 1)

        action_row = QHBoxLayout()
        action_row.addWidget(btn_make)
        action_row.addWidget(btn_auto_this)
        action_row.addWidget(btn_commit)
        action_row.addStretch(1)
        action_row.addWidget(btn_close)
        layout.addLayout(action_row)

        btn_gen.clicked.connect(self._generate_pool)
        btn_order.clicked.connect(self._compute_order)
        btn_start.clicked.connect(self._auto_complete)
        btn_make.clicked.connect(self._make_pick)
        btn_auto_this.clicked.connect(self._auto_pick_current)
        btn_commit.clicked.connect(self._commit_to_rosters)
        btn_close.clicked.connect(self._close_if_complete)
        self.search.textChanged.connect(self._apply_filter)
        self.table.itemSelectionChanged.connect(self._update_preview_from_selection)

        # Show existing pool/state
        self.pool = load_draft_pool(self.year)
        if self.pool:
            self.status.setText(f"Draft pool loaded ({len(self.pool)} players).")
            self._populate_table(self.pool)
        self.state = load_state(self.year) or {}
        self._order_names = {t.team_id: f"{t.city} {t.name}" for t in load_teams()}
        self._remove_already_selected()
        self._update_status_round()
        self._rebuild_board()

    def _generate_pool(self) -> None:
        pool = generate_draft_pool(self.year, size=200)
        save_draft_pool(self.year, pool)
        self.pool = [p.__dict__ for p in pool]
        self.status.setText(f"Draft pool generated ({len(pool)} players).")
        self._populate_table(self.pool)

    def _compute_order(self) -> None:
        order = compute_order_from_season_stats(seed=self.year)
        if not order:
            QMessageBox.warning(self, "Draft Order", "Unable to compute order from season stats.")
            return
        self.state = initialize_state(self.year, order=order)
        self.status.setText(f"Draft order computed for {len(order)} teams. Ready to draft.")
        self._update_status_round()
        self._rebuild_board()

    def _auto_complete(self) -> None:
        if not self.pool:
            QMessageBox.warning(self, "Draft", "Generate the draft pool first.")
            return
        if not self.state.get("order"):
            self._compute_order()
            if not self.state.get("order"):
                return
        while not self._is_complete():
            self._auto_pick_current()
        QMessageBox.information(self, "Draft Complete", "Auto-draft of all rounds complete.")
        self.accept()

    # UI helpers
    def _populate_table(self, rows: list[dict]) -> None:
        self.table.setRowCount(len(rows))
        for r, p in enumerate(rows):
            name = f"{p.get('first_name','')} {p.get('last_name','')}".strip()
            bt = f"{p.get('bats','?')}/{p.get('throws','?')}"
            pos = p.get("primary_position", "?")
            chphsp = f"{p.get('ch',0)}/{p.get('ph',0)}/{p.get('sp',0)}"
            armfa = f"{p.get('arm',0)}/{p.get('fa',0)}"
            self.table.setItem(r, 0, QTableWidgetItem(p.get("player_id","")))
            self.table.setItem(r, 1, QTableWidgetItem(name))
            self.table.setItem(r, 2, QTableWidgetItem(pos))
            self.table.setItem(r, 3, QTableWidgetItem(bt))
            self.table.setItem(r, 4, QTableWidgetItem(chphsp))
            self.table.setItem(r, 5, QTableWidgetItem(armfa))
        self.table.resizeColumnsToContents()
        # Maintain preview after refresh
        self._update_preview_from_selection()

    def _apply_filter(self) -> None:
        term = (self.search.text() or "").strip().lower()
        for r in range(self.table.rowCount()):
            match = not term
            if not match:
                for c in range(self.table.columnCount()):
                    item = self.table.item(r, c)
                    if item and term in item.text().lower():
                        match = True
                        break
            self.table.setRowHidden(r, not match)

    # Draft mechanics
    def _remove_already_selected(self) -> None:
        picks = self.state.get("selected", [])
        if not picks:
            return
        selected_ids = {p.get("player_id") for p in picks}
        self.pool = [p for p in self.pool if p.get("player_id") not in selected_ids]
        self._populate_table(self.pool)
        self._rebuild_board()

    def _update_status_round(self) -> None:
        if not self.state.get("order"):
            return
        overall = int(self.state.get("overall_pick", 1))
        teams_count = len(self.state["order"])
        rnd = (overall - 1) // teams_count + 1
        idx = (overall - 1) % teams_count
        team_id = self.state["order"][idx]
        team_name = self._order_names.get(team_id, team_id)
        self.state["round"] = rnd
        banner = f"Round {rnd}/{self.DRAFT_ROUNDS} — Pick {idx+1} of {teams_count} — On the clock: {team_name}"
        self.status.setText(banner)
        self.onclock.setText(f"On the clock: {team_name}")

    def _current_team(self) -> str | None:
        if not self.state.get("order"):
            return None
        overall = int(self.state.get("overall_pick", 1))
        idx = (overall - 1) % len(self.state["order"])
        return self.state["order"][idx]

    def _score(self, p: dict) -> int:
        if p.get("is_pitcher"):
            return int(p.get("endurance", 0)) + int(p.get("control", 0)) + int(p.get("movement", 0))
        return int(p.get("ch", 0)) + int(p.get("ph", 0)) + int(p.get("sp", 0))

    def _make_pick(self) -> None:
        team_id = self._current_team()
        if team_id is None:
            return
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Draft", "Select a prospect to make a pick.")
            return
        pid = self.table.item(row, 0).text()
        self._commit_pick(team_id, pid)

    def _auto_pick_current(self) -> None:
        team_id = self._current_team()
        if team_id is None:
            return
        if not self.pool:
            return
        # choose best by score
        best = max(self.pool, key=self._score)
        self._commit_pick(team_id, best.get("player_id", ""))

    def _commit_pick(self, team_id: str, pid: str) -> None:
        if not pid:
            return
        overall = int(self.state.get("overall_pick", 1))
        rnd = int(self.state.get("round", 1))
        self.state.setdefault("selected", []).append({
            "round": rnd,
            "overall_pick": overall,
            "team_id": team_id,
            "player_id": pid,
        })
        append_result(self.year, team_id=team_id, player_id=pid, rnd=rnd, overall=overall)
        # Remove from pool and advance
        self.pool = [p for p in self.pool if p.get("player_id") != pid]
        self._populate_table(self.pool)
        self.state["overall_pick"] = overall + 1
        save_state(self.year, self.state)
        if not self._is_complete():
            self._update_status_round()
            self._rebuild_board()

    def _is_complete(self) -> bool:
        if not self.state.get("order"):
            return False
        total_picks = self.DRAFT_ROUNDS * len(self.state["order"])
        return int(self.state.get("overall_pick", 1)) > total_picks

    def _close_if_complete(self) -> None:
        if not self._is_complete():
            if QMessageBox.question(self, "Close Draft", "Draft not complete. Close anyway?",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No) != QMessageBox.StandardButton.Yes:
                return
        self.accept()

    def _commit_to_rosters(self) -> None:
        try:
            from services.draft_assignment import commit_draft_results
            summary = commit_draft_results(self.year)
            # Log a league news entry
            try:
                log_news_event(
                    f"Amateur Draft {self.year} committed: "
                    f"{summary.get('players_added',0)} players added; "
                    f"{summary.get('roster_assigned',0)} roster assignments"
                )
            except Exception:
                pass
            # Update parent SeasonProgress notes (toast-like)
            try:
                parent = self.parent()
                if parent is not None and hasattr(parent, 'notes_label'):
                    parent.notes_label.setText(
                        f"Draft {self.year} committed — players added: {summary.get('players_added',0)}, "
                        f"roster assignments: {summary.get('roster_assigned',0)}"
                    )
            except Exception:
                pass
            QMessageBox.information(
                self,
                "Draft Assignments",
                f"Players added: {summary.get('players_added',0)}\n"
                f"Roster assignments: {summary.get('roster_assigned',0)}",
            )
        except Exception as exc:
            QMessageBox.warning(self, "Commit Failed", str(exc))

    # Board and preview helpers
    def _rebuild_board(self) -> None:
        # Show last 10 picks
        picks = list(self.state.get("selected", []))
        tail = picks[-10:]
        self.board.setRowCount(len(tail))
        for i, sel in enumerate(tail):
            pick_no = sel.get("overall_pick", 0)
            team = self._order_names.get(sel.get("team_id", ""), sel.get("team_id", ""))
            player = sel.get("player_id", "")
            self.board.setItem(i, 0, QTableWidgetItem(str(pick_no)))
            self.board.setItem(i, 1, QTableWidgetItem(team))
            self.board.setItem(i, 2, QTableWidgetItem(player))
        self.board.resizeColumnsToContents()

    def _update_preview_from_selection(self) -> None:
        row = self.table.currentRow()
        if row < 0:
            for v in self._pv_values.values():
                v.setText("—")
            return
        pid = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        name = self.table.item(row, 1).text() if self.table.item(row, 1) else ""
        pos = self.table.item(row, 2).text() if self.table.item(row, 2) else ""
        bt = self.table.item(row, 3).text() if self.table.item(row, 3) else ""
        hit = self.table.item(row, 4).text() if self.table.item(row, 4) else ""
        df = self.table.item(row, 5).text() if self.table.item(row, 5) else ""
        self._pv_values["id"].setText(pid)
        self._pv_values["name"].setText(name)
        self._pv_values["pos"].setText(pos)
        self._pv_values["bt"].setText(bt)
        self._pv_values["hit"].setText(hit)
        self._pv_values["def"].setText(df)


__all__ = ["DraftConsole"]

